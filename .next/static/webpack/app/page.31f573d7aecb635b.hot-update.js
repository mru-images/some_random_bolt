"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useSupabaseData.ts":
/*!**********************************!*\
  !*** ./hooks/useSupabaseData.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSupabaseData: function() { return /* binding */ useSupabaseData; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n\nfunction useSupabaseData(user) {\n    const [songs, setSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [playlists, setPlaylists] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [likedSongs, setLikedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Set());\n    const [lastPlayedSong, setLastPlayedSong] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [currentSongStartTime, setCurrentSongStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const currentSongRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Convert database song to UI song format\n    const convertDatabaseSong = function(dbSong) {\n        let isLiked = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return {\n            file_id: dbSong.file_id,\n            img_id: dbSong.img_id,\n            name: dbSong.name,\n            artist: dbSong.artist,\n            language: dbSong.language,\n            tags: dbSong.tags,\n            views: dbSong.views,\n            likes: dbSong.likes,\n            id: dbSong.file_id.toString(),\n            image: \"https://images.pexels.com/photos/\".concat(dbSong.img_id, \"/pexels-photo-\").concat(dbSong.img_id, \".jpeg?auto=compress&cs=tinysrgb&w=300\"),\n            isLiked\n        };\n    };\n    // Fetch all songs\n    const fetchSongs = async ()=>{\n        if (!user) {\n            setSongs([]);\n            return;\n        }\n        try {\n            const { data: songsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"songs\").select(\"*\").order(\"views\", {\n                ascending: false\n            });\n            if (error) throw error;\n            let userLikedSongs = new Set();\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", user.id);\n            if (likedData) {\n                userLikedSongs = new Set(likedData.map((item)=>item.song_id));\n                setLikedSongs(userLikedSongs);\n            }\n            const convertedSongs = (songsData === null || songsData === void 0 ? void 0 : songsData.map((song)=>convertDatabaseSong(song, userLikedSongs.has(song.file_id)))) || [];\n            const sortedSongs = [\n                ...convertedSongs\n            ].sort((a, b)=>{\n                const aScore = a.views + a.likes;\n                const bScore = b.views + b.likes;\n                return bScore - aScore;\n            });\n            setSongs(sortedSongs);\n            const { data: userData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"users\").select(\"last_song_file_id\").eq(\"id\", user.id).single();\n            if (userData === null || userData === void 0 ? void 0 : userData.last_song_file_id) {\n                const lastSong = convertedSongs.find((song)=>song.file_id === userData.last_song_file_id);\n                if (lastSong) {\n                    setLastPlayedSong(lastSong);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching songs:\", error);\n            setSongs([]) // Set empty array on error\n            ;\n        }\n    };\n    async function getPersonalizedSongs(userId, currentSong, listenedSongs) {\n        // 1. Fetch all songs\n        const { data: songs } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"songs\").select(\"*\");\n        if (!songs) return [];\n        // 2. Fetch listening history\n        const { data: history } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"history\").select(\"*\").eq(\"user_id\", userId);\n        const historyMap = new Map(history === null || history === void 0 ? void 0 : history.map((h)=>[\n                h.song_id,\n                h.minutes_listened\n            ]));\n        const recommendations = songs.filter((song)=>{\n            // Exclude current song\n            if (song.file_id === currentSong.file_id) return false;\n            // Exclude listened songs if provided\n            if (listenedSongs && listenedSongs.has(song.file_id.toString())) {\n                console.log(\"\\uD83D\\uDEAB Excluding listened song: \".concat(song.name, \" by \").concat(song.artist));\n                return false;\n            }\n            return true;\n        }).map((song)=>{\n            let score = 0;\n            // ðŸŽ¯ Tag Match\n            const matchingTags = song.tags.filter((tag)=>currentSong.tags.includes(tag));\n            score += matchingTags.length * 10;\n            // ðŸ‘¤ Artist Match\n            if (song.artist === currentSong.artist) {\n                score += 20;\n            }\n            // â± Listening History Boost\n            const listenedMinutes = historyMap.get(song.file_id) || 0;\n            score += listenedMinutes;\n            // â¤ï¸ Likes Boost\n            score += (song.likes || 0) / 100;\n            // ðŸ‘ Views Boost\n            score += (song.views || 0) / 1000;\n            // Add some randomness to avoid always getting the same recommendations\n            score += Math.random() * 5;\n            return {\n                song,\n                score\n            };\n        });\n        // 3. Sort and return top 10 for better variety\n        const top5 = recommendations.sort((a, b)=>b.score - a.score).slice(0, 10).map((entry)=>entry.song);\n        console.log(\"\\uD83C\\uDFB5 Personalized Top 10 Songs (excluding listened):\", top5.map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n        console.log(\"\\uD83C\\uDFB5 Total listened songs excluded:\", listenedSongs ? listenedSongs.size : 0);\n        return top5;\n    }\n    // Fetch user playlists\n    const fetchPlaylists = async ()=>{\n        if (!user) {\n            setPlaylists([]);\n            return;\n        }\n        try {\n            const { data: playlistsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").select(\"\\n          id,\\n          name,\\n          playlist_songs (\\n            songs (*)\\n          )\\n        \").eq(\"user_id\", user.id);\n            if (error) throw error;\n            const convertedPlaylists = (playlistsData === null || playlistsData === void 0 ? void 0 : playlistsData.map((playlist)=>{\n                var _playlist_playlist_songs, _playlistSongs_;\n                const playlistSongs = ((_playlist_playlist_songs = playlist.playlist_songs) === null || _playlist_playlist_songs === void 0 ? void 0 : _playlist_playlist_songs.map((ps)=>convertDatabaseSong(ps.songs, likedSongs.has(ps.songs.file_id)))) || [];\n                return {\n                    id: playlist.id.toString(),\n                    name: playlist.name,\n                    songCount: playlistSongs.length,\n                    image: ((_playlistSongs_ = playlistSongs[0]) === null || _playlistSongs_ === void 0 ? void 0 : _playlistSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                    songs: playlistSongs\n                };\n            })) || [];\n            setPlaylists(convertedPlaylists);\n        } catch (error) {\n            console.error(\"Error fetching playlists:\", error);\n        }\n    };\n    // Toggle like song\n    const toggleLike = async (songId)=>{\n        if (!user) return;\n        const songFileId = parseInt(songId);\n        const isCurrentlyLiked = likedSongs.has(songFileId);\n        try {\n            if (isCurrentlyLiked) {\n                // Remove from liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").delete().eq(\"user_id\", user.id).eq(\"song_id\", songFileId);\n                if (error) throw error;\n                // Decrement likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"decrement_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>{\n                    const newSet = new Set(prev);\n                    newSet.delete(songFileId);\n                    return newSet;\n                });\n            } else {\n                // Add to liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").insert({\n                    user_id: user.id,\n                    song_id: songFileId\n                });\n                if (error) throw error;\n                // Increment likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"increment_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>new Set(prev).add(songFileId));\n            }\n            // Update songs state\n            // Update songs state\n            setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                        ...song,\n                        isLiked: !isCurrentlyLiked,\n                        likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                    } : song));\n            // Update playlists state\n            setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                        ...playlist,\n                        songs: playlist.songs.map((song)=>song.id === songId ? {\n                                ...song,\n                                isLiked: !isCurrentlyLiked,\n                                likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                            } : song)\n                    })));\n        } catch (error) {\n            console.error(\"Error toggling like:\", error);\n        }\n    };\n    // Create playlist\n    const createPlaylist = async (name)=>{\n        if (!user) return;\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").insert({\n                user_id: user.id,\n                name\n            }).select().single();\n            if (error) throw error;\n            const newPlaylist = {\n                id: data.id.toString(),\n                name: data.name,\n                songCount: 0,\n                image: \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                songs: []\n            };\n            setPlaylists((prev)=>[\n                    ...prev,\n                    newPlaylist\n                ]);\n        } catch (error) {\n            console.error(\"Error creating playlist:\", error);\n        }\n    };\n    // Delete playlist\n    const deletePlaylist = async (playlistId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").delete().eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.filter((playlist)=>playlist.id !== playlistId));\n        } catch (error) {\n            console.error(\"Error deleting playlist:\", error);\n        }\n    };\n    // Rename playlist\n    const renamePlaylist = async (playlistId, newName)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").update({\n                name: newName\n            }).eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>playlist.id === playlistId ? {\n                        ...playlist,\n                        name: newName\n                    } : playlist));\n        } catch (error) {\n            console.error(\"Error renaming playlist:\", error);\n        }\n    };\n    // Add song to playlist\n    const addSongToPlaylist = async (playlistId, song)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlist_songs\").insert({\n                playlist_id: parseInt(playlistId),\n                song_id: song.file_id\n            });\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        const songExists = playlist.songs.some((s)=>s.id === song.id);\n                        if (!songExists) {\n                            var _updatedSongs_;\n                            const updatedSongs = [\n                                ...playlist.songs,\n                                song\n                            ];\n                            return {\n                                ...playlist,\n                                songs: updatedSongs,\n                                songCount: updatedSongs.length,\n                                image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || playlist.image\n                            };\n                        }\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error adding song to playlist:\", error);\n        }\n    };\n    // Remove song from playlist\n    const removeSongFromPlaylist = async (playlistId, songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlist_songs\").delete().eq(\"playlist_id\", parseInt(playlistId)).eq(\"song_id\", parseInt(songId));\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        var _updatedSongs_;\n                        const updatedSongs = playlist.songs.filter((song)=>song.id !== songId);\n                        return {\n                            ...playlist,\n                            songs: updatedSongs,\n                            songCount: updatedSongs.length,\n                            image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\"\n                        };\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error removing song from playlist:\", error);\n        }\n    };\n    // Update last song in user profile\n    const updateLastSong = async (songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"users\").update({\n                last_song_file_id: parseInt(songId)\n            }).eq(\"id\", user.id);\n            if (error) throw error;\n        } catch (error) {\n            console.error(\"Error updating last song:\", error);\n        }\n    };\n    // Record listening history with proper time tracking\n    const recordListeningHistory = async (songId)=>{\n        if (!user) return;\n        // If there's a previous song playing, record its listening time\n        if (currentSongRef.current && currentSongStartTime) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: user.id,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"âŒ Error recording song history:\", error);\n                    } else {\n                        console.log(\"âœ… History updated: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording previous song history:\", error);\n                }\n            }\n        }\n        // Set new song as current\n        currentSongRef.current = songId;\n        setCurrentSongStartTime(new Date());\n        // Update last song in user profile\n        await updateLastSong(songId);\n        try {\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"increment_song_views\", {\n                song_file_id: parseInt(songId)\n            });\n        } catch (error) {\n            console.error(\"Error incrementing song views:\", error);\n        }\n    };\n    // Stop current song tracking (when player is closed)\n    const stopCurrentSongTracking = async ()=>{\n        if (currentSongRef.current && currentSongStartTime && user) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: user.id,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"âŒ Error recording song history on stop:\", error);\n                    } else {\n                        console.log(\"\\uD83D\\uDED1 History updated on stop: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording final song history:\", error);\n                }\n            }\n        }\n        currentSongRef.current = null;\n        setCurrentSongStartTime(null);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const loadData = async ()=>{\n            if (!user) {\n                // Reset data when user logs out\n                setSongs([]);\n                setPlaylists([]);\n                setLikedSongs(new Set());\n                setLastPlayedSong(null);\n                setLoading(false);\n                return;\n            }\n            try {\n                setLoading(true);\n                await Promise.all([\n                    fetchSongs(),\n                    fetchPlaylists()\n                ]);\n            } catch (error) {\n                console.error(\"Error loading data:\", error);\n            } finally{\n                setLoading(false);\n            }\n        };\n        loadData();\n    }, [\n        user\n    ]);\n    return {\n        songs,\n        playlists,\n        likedSongs: songs.filter((song)=>song.isLiked),\n        lastPlayedSong,\n        loading,\n        toggleLike,\n        createPlaylist,\n        deletePlaylist,\n        renamePlaylist,\n        addSongToPlaylist,\n        removeSongFromPlaylist,\n        recordListeningHistory,\n        stopCurrentSongTracking,\n        refreshData: ()=>{\n            fetchSongs();\n            fetchPlaylists();\n        },\n        getPersonalizedSongs\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1EO0FBRXNCO0FBR2xFLFNBQVNJLGdCQUFnQkMsSUFBaUI7SUFDL0MsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdQLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsTUFBTSxDQUFDUSxXQUFXQyxhQUFhLEdBQUdULCtDQUFRQSxDQUFhLEVBQUU7SUFDekQsTUFBTSxDQUFDVSxZQUFZQyxjQUFjLEdBQUdYLCtDQUFRQSxDQUFjLElBQUlZO0lBQzlELE1BQU0sQ0FBQ0MsZ0JBQWdCQyxrQkFBa0IsR0FBR2QsK0NBQVFBLENBQWM7SUFDbEUsTUFBTSxDQUFDZSxTQUFTQyxXQUFXLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNpQixzQkFBc0JDLHdCQUF3QixHQUFHbEIsK0NBQVFBLENBQWM7SUFDOUUsTUFBTW1CLGlCQUFpQmpCLDZDQUFNQSxDQUFnQjtJQUU3QywwQ0FBMEM7SUFDMUMsTUFBTWtCLHNCQUFzQixTQUFDQztZQUFzQkMsMkVBQW1CO2VBQWlCO1lBQ3JGQyxTQUFTRixPQUFPRSxPQUFPO1lBQ3ZCQyxRQUFRSCxPQUFPRyxNQUFNO1lBQ3JCQyxNQUFNSixPQUFPSSxJQUFJO1lBQ2pCQyxRQUFRTCxPQUFPSyxNQUFNO1lBQ3JCQyxVQUFVTixPQUFPTSxRQUFRO1lBQ3pCQyxNQUFNUCxPQUFPTyxJQUFJO1lBQ2pCQyxPQUFPUixPQUFPUSxLQUFLO1lBQ25CQyxPQUFPVCxPQUFPUyxLQUFLO1lBQ25CQyxJQUFJVixPQUFPRSxPQUFPLENBQUNTLFFBQVE7WUFDM0JDLE9BQU8sb0NBQWtFWixPQUE5QkEsT0FBT0csTUFBTSxFQUFDLGtCQUE4QixPQUFkSCxPQUFPRyxNQUFNLEVBQUM7WUFDdkZGO1FBQ0Y7O0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU1ZLGFBQWE7UUFDakIsSUFBSSxDQUFDN0IsTUFBTTtZQUNURSxTQUFTLEVB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LFdBQVc7WUFDYjtRQUNGO1FBRUF3SDtJQUNGLEdBQUc7UUFBQ25JO0tBQUs7SUFFVCxPQUFPO1FBQ0xDO1FBQ0FFO1FBQ0FFLFlBQVlKLE1BQU1tRSxNQUFNLENBQUN4QixDQUFBQSxPQUFRQSxLQUFLM0IsT0FBTztRQUM3Q1Q7UUFDQUU7UUFDQWtGO1FBQ0FlO1FBQ0FFO1FBQ0FFO1FBQ0FHO1FBQ0FLO1FBQ0FFO1FBQ0FTO1FBQ0FJLGFBQWE7WUFDWHpHO1lBQ0F1RDtRQUNGO1FBQ0ExQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlU3VwYWJhc2VEYXRhLnRzP2FiZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuaW1wb3J0IHsgc3VwYWJhc2UsIERhdGFiYXNlU29uZywgRGF0YWJhc2VQbGF5bGlzdCB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJ1xuaW1wb3J0IHsgU29uZywgUGxheWxpc3QgfSBmcm9tICdAL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3VwYWJhc2VEYXRhKHVzZXI6IFVzZXIgfCBudWxsKSB7XG4gIGNvbnN0IFtzb25ncywgc2V0U29uZ3NdID0gdXNlU3RhdGU8U29uZ1tdPihbXSlcbiAgY29uc3QgW3BsYXlsaXN0cywgc2V0UGxheWxpc3RzXSA9IHVzZVN0YXRlPFBsYXlsaXN0W10+KFtdKVxuICBjb25zdCBbbGlrZWRTb25ncywgc2V0TGlrZWRTb25nc10gPSB1c2VTdGF0ZTxTZXQ8bnVtYmVyPj4obmV3IFNldCgpKVxuICBjb25zdCBbbGFzdFBsYXllZFNvbmcsIHNldExhc3RQbGF5ZWRTb25nXSA9IHVzZVN0YXRlPFNvbmcgfCBudWxsPihudWxsKVxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuICBjb25zdCBbY3VycmVudFNvbmdTdGFydFRpbWUsIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lXSA9IHVzZVN0YXRlPERhdGUgfCBudWxsPihudWxsKVxuICBjb25zdCBjdXJyZW50U29uZ1JlZiA9IHVzZVJlZjxzdHJpbmcgfCBudWxsPihudWxsKVxuXG4gIC8vIENvbnZlcnQgZGF0YWJhc2Ugc29uZyB0byBVSSBzb25nIGZvcm1hdFxuICBjb25zdCBjb252ZXJ0RGF0YWJhc2VTb25nID0gKGRiU29uZzogRGF0YWJhc2VTb25nLCBpc0xpa2VkOiBib29sZWFuID0gZmFsc2UpOiBTb25nID0+ICh7XG4gICAgZmlsZV9pZDogZGJTb25nLmZpbGVfaWQsXG4gICAgaW1nX2lkOiBkYlNvbmcuaW1nX2lkLFxuICAgIG5hbWU6IGRiU29uZy5uYW1lLFxuICAgIGFydGlzdDogZGJTb25nLmFydGlzdCxcbiAgICBsYW5ndWFnZTogZGJTb25nLmxhbmd1YWdlLFxuICAgIHRhZ3M6IGRiU29uZy50YWdzLFxuICAgIHZpZXdzOiBkYlNvbmcudmlld3MsXG4gICAgbGlrZXM6IGRiU29uZy5saWtlcyxcbiAgICBpZDogZGJTb25nLmZpbGVfaWQudG9TdHJpbmcoKSxcbiAgICBpbWFnZTogYGh0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLyR7ZGJTb25nLmltZ19pZH0vcGV4ZWxzLXBob3RvLSR7ZGJTb25nLmltZ19pZH0uanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwYCxcbiAgICBpc0xpa2VkXG4gIH0pXG5cbiAgLy8gRmV0Y2ggYWxsIHNvbmdzXG4gIGNvbnN0IGZldGNoU29uZ3MgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICBzZXRTb25ncyhbXSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhOiBzb25nc0RhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc29uZ3MnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCd2aWV3cycsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIGxldCB1c2VyTGlrZWRTb25ncyA9IG5ldyBTZXQ8bnVtYmVyPigpXG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YTogbGlrZWREYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAuc2VsZWN0KCdzb25nX2lkJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgIFxuICAgICAgaWYgKGxpa2VkRGF0YSkge1xuICAgICAgICB1c2VyTGlrZWRTb25ncyA9IG5ldyBTZXQobGlrZWREYXRhLm1hcChpdGVtID0+IGl0ZW0uc29uZ19pZCkpXG4gICAgICAgIHNldExpa2VkU29uZ3ModXNlckxpa2VkU29uZ3MpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnZlcnRlZFNvbmdzID0gc29uZ3NEYXRhPy5tYXAoc29uZyA9PiBcbiAgICAgICAgY29udmVydERhdGFiYXNlU29uZyhzb25nLCB1c2VyTGlrZWRTb25ncy5oYXMoc29uZy5maWxlX2lkKSlcbiAgICAgICkgfHwgW11cblxuICAgICAgY29uc3Qgc29ydGVkU29uZ3MgPSBbLi4uY29udmVydGVkU29uZ3NdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgYVNjb3JlID0gYS52aWV3cyArIGEubGlrZXM7XG4gICAgICAgIGNvbnN0IGJTY29yZSA9IGIudmlld3MgKyBiLmxpa2VzO1xuICAgICAgICByZXR1cm4gYlNjb3JlIC0gYVNjb3JlO1xuICAgICAgfSk7XG5cbiAgICAgIHNldFNvbmdzKHNvcnRlZFNvbmdzKTtcblxuICAgICAgY29uc3QgeyBkYXRhOiB1c2VyRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnNlbGVjdCgnbGFzdF9zb25nX2ZpbGVfaWQnKVxuICAgICAgICAuZXEoJ2lkJywgdXNlci5pZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmICh1c2VyRGF0YT8ubGFzdF9zb25nX2ZpbGVfaWQpIHtcbiAgICAgICAgY29uc3QgbGFzdFNvbmcgPSBjb252ZXJ0ZWRTb25ncy5maW5kKHNvbmcgPT4gc29uZy5maWxlX2lkID09PSB1c2VyRGF0YS5sYXN0X3NvbmdfZmlsZV9pZClcbiAgICAgICAgaWYgKGxhc3RTb25nKSB7XG4gICAgICAgICAgc2V0TGFzdFBsYXllZFNvbmcobGFzdFNvbmcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgc29uZ3M6JywgZXJyb3IpXG4gICAgICBzZXRTb25ncyhbXSkgLy8gU2V0IGVtcHR5IGFycmF5IG9uIGVycm9yXG4gICAgfVxuICB9XG5cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UGVyc29uYWxpemVkU29uZ3ModXNlcklkOiBzdHJpbmcsIGN1cnJlbnRTb25nOiBTb25nLCBsaXN0ZW5lZFNvbmdzPzogU2V0PHN0cmluZz4pIHtcbiAgLy8gMS4gRmV0Y2ggYWxsIHNvbmdzXG4gIGNvbnN0IHsgZGF0YTogc29uZ3MgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3NvbmdzJykuc2VsZWN0KCcqJyk7XG4gIGlmICghc29uZ3MpIHJldHVybiBbXTtcblxuICAvLyAyLiBGZXRjaCBsaXN0ZW5pbmcgaGlzdG9yeVxuICBjb25zdCB7IGRhdGE6IGhpc3RvcnkgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2hpc3RvcnknKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG4gIGNvbnN0IGhpc3RvcnlNYXAgPSBuZXcgTWFwKGhpc3Rvcnk/Lm1hcCgoaCkgPT4gW2guc29uZ19pZCwgaC5taW51dGVzX2xpc3RlbmVkXSkpO1xuXG4gIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IHNvbmdzXG4gICAgLmZpbHRlcigoc29uZykgPT4ge1xuICAgICAgLy8gRXhjbHVkZSBjdXJyZW50IHNvbmdcbiAgICAgIGlmIChzb25nLmZpbGVfaWQgPT09IGN1cnJlbnRTb25nLmZpbGVfaWQpIHJldHVybiBmYWxzZTtcbiAgICAgIFxuICAgICAgLy8gRXhjbHVkZSBsaXN0ZW5lZCBzb25ncyBpZiBwcm92aWRlZFxuICAgICAgaWYgKGxpc3RlbmVkU29uZ3MgJiYgbGlzdGVuZWRTb25ncy5oYXMoc29uZy5maWxlX2lkLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIEV4Y2x1ZGluZyBsaXN0ZW5lZCBzb25nOiAke3NvbmcubmFtZX0gYnkgJHtzb25nLmFydGlzdH1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KVxuICAgIC5tYXAoKHNvbmcpID0+IHtcbiAgICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAgIC8vIPCfjq8gVGFnIE1hdGNoXG4gICAgICBjb25zdCBtYXRjaGluZ1RhZ3MgPSBzb25nLnRhZ3MuZmlsdGVyKCh0YWc6IHN0cmluZykgPT5cbiAgICAgICAgY3VycmVudFNvbmcudGFncy5pbmNsdWRlcyh0YWcpXG4gICAgICApO1xuICAgICAgc2NvcmUgKz0gbWF0Y2hpbmdUYWdzLmxlbmd0aCAqIDEwO1xuXG4gICAgICAvLyDwn5GkIEFydGlzdCBNYXRjaFxuICAgICAgaWYgKHNvbmcuYXJ0aXN0ID09PSBjdXJyZW50U29uZy5hcnRpc3QpIHtcbiAgICAgICAgc2NvcmUgKz0gMjA7XG4gICAgICB9XG5cbiAgICAgIC8vIOKPsSBMaXN0ZW5pbmcgSGlzdG9yeSBCb29zdFxuICAgICAgY29uc3QgbGlzdGVuZWRNaW51dGVzID0gaGlzdG9yeU1hcC5nZXQoc29uZy5maWxlX2lkKSB8fCAwO1xuICAgICAgc2NvcmUgKz0gbGlzdGVuZWRNaW51dGVzO1xuXG4gICAgICAvLyDinaTvuI8gTGlrZXMgQm9vc3RcbiAgICAgIHNjb3JlICs9IChzb25nLmxpa2VzIHx8IDApIC8gMTAwO1xuXG4gICAgICAvLyDwn5GBIFZpZXdzIEJvb3N0XG4gICAgICBzY29yZSArPSAoc29uZy52aWV3cyB8fCAwKSAvIDEwMDA7XG5cbiAgICAgIC8vIEFkZCBzb21lIHJhbmRvbW5lc3MgdG8gYXZvaWQgYWx3YXlzIGdldHRpbmcgdGhlIHNhbWUgcmVjb21tZW5kYXRpb25zXG4gICAgICBzY29yZSArPSBNYXRoLnJhbmRvbSgpICogNTtcbiAgICAgIHJldHVybiB7IHNvbmcsIHNjb3JlIH07XG4gICAgfSk7XG5cbiAgLy8gMy4gU29ydCBhbmQgcmV0dXJuIHRvcCAxMCBmb3IgYmV0dGVyIHZhcmlldHlcbiAgY29uc3QgdG9wNSA9IHJlY29tbWVuZGF0aW9uc1xuICAgIC5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSlcbiAgICAuc2xpY2UoMCwgMTApXG4gICAgLm1hcCgoZW50cnkpID0+IGVudHJ5LnNvbmcpO1xuXG4gIGNvbnNvbGUubG9nKCfwn461IFBlcnNvbmFsaXplZCBUb3AgMTAgU29uZ3MgKGV4Y2x1ZGluZyBsaXN0ZW5lZCk6JywgdG9wNS5tYXAocyA9PiBgJHtzLm5hbWV9IGJ5ICR7cy5hcnRpc3R9YCkpO1xuICBjb25zb2xlLmxvZygn8J+OtSBUb3RhbCBsaXN0ZW5lZCBzb25ncyBleGNsdWRlZDonLCBsaXN0ZW5lZFNvbmdzID8gbGlzdGVuZWRTb25ncy5zaXplIDogMCk7XG4gIHJldHVybiB0b3A1O1xufVxuXG4gIC8vIEZldGNoIHVzZXIgcGxheWxpc3RzXG4gIGNvbnN0IGZldGNoUGxheWxpc3RzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcikge1xuICAgICAgc2V0UGxheWxpc3RzKFtdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogcGxheWxpc3RzRGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAuc2VsZWN0KGBcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBsYXlsaXN0X3NvbmdzIChcbiAgICAgICAgICAgIHNvbmdzICgqKVxuICAgICAgICAgIClcbiAgICAgICAgYClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zdCBjb252ZXJ0ZWRQbGF5bGlzdHM6IFBsYXlsaXN0W10gPSBwbGF5bGlzdHNEYXRhPy5tYXAocGxheWxpc3QgPT4ge1xuICAgICAgICBjb25zdCBwbGF5bGlzdFNvbmdzID0gcGxheWxpc3QucGxheWxpc3Rfc29uZ3M/Lm1hcCgocHM6IGFueSkgPT4gXG4gICAgICAgICAgY29udmVydERhdGFiYXNlU29uZyhwcy5zb25ncywgbGlrZWRTb25ncy5oYXMocHMuc29uZ3MuZmlsZV9pZCkpXG4gICAgICAgICkgfHwgW11cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBwbGF5bGlzdC5pZC50b1N0cmluZygpLFxuICAgICAgICAgIG5hbWU6IHBsYXlsaXN0Lm5hbWUsXG4gICAgICAgICAgc29uZ0NvdW50OiBwbGF5bGlzdFNvbmdzLmxlbmd0aCxcbiAgICAgICAgICBpbWFnZTogcGxheWxpc3RTb25nc1swXT8uaW1hZ2UgfHwgJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJyxcbiAgICAgICAgICBzb25nczogcGxheWxpc3RTb25nc1xuICAgICAgICB9XG4gICAgICB9KSB8fCBbXVxuXG4gICAgICBzZXRQbGF5bGlzdHMoY29udmVydGVkUGxheWxpc3RzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwbGF5bGlzdHM6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gVG9nZ2xlIGxpa2Ugc29uZ1xuICBjb25zdCB0b2dnbGVMaWtlID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gIGlmICghdXNlcikgcmV0dXJuO1xuXG4gIGNvbnN0IHNvbmdGaWxlSWQgPSBwYXJzZUludChzb25nSWQpO1xuICBjb25zdCBpc0N1cnJlbnRseUxpa2VkID0gbGlrZWRTb25ncy5oYXMoc29uZ0ZpbGVJZCk7XG5cbiAgdHJ5IHtcbiAgICBpZiAoaXNDdXJyZW50bHlMaWtlZCkge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gbGlrZWRfc29uZ3NcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdsaWtlZF9zb25ncycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgICAuZXEoJ3NvbmdfaWQnLCBzb25nRmlsZUlkKTtcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblxuICAgICAgLy8gRGVjcmVtZW50IGxpa2VzXG4gICAgICBhd2FpdCBzdXBhYmFzZS5ycGMoJ2RlY3JlbWVudF9zb25nX2xpa2VzJywgeyBzb25nX2ZpbGVfaWQ6IHNvbmdGaWxlSWQgfSk7XG5cbiAgICAgIHNldExpa2VkU29uZ3MocHJldiA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1NldCA9IG5ldyBTZXQocHJldik7XG4gICAgICAgIG5ld1NldC5kZWxldGUoc29uZ0ZpbGVJZCk7XG4gICAgICAgIHJldHVybiBuZXdTZXQ7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIHRvIGxpa2VkX3NvbmdzXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB1c2VyX2lkOiB1c2VyLmlkLFxuICAgICAgICAgIHNvbmdfaWQ6IHNvbmdGaWxlSWQsXG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXG4gICAgICAvLyBJbmNyZW1lbnQgbGlrZXNcbiAgICAgIGF3YWl0IHN1cGFiYXNlLnJwYygnaW5jcmVtZW50X3NvbmdfbGlrZXMnLCB7IHNvbmdfZmlsZV9pZDogc29uZ0ZpbGVJZCB9KTtcblxuICAgICAgc2V0TGlrZWRTb25ncyhwcmV2ID0+IG5ldyBTZXQocHJldikuYWRkKHNvbmdGaWxlSWQpKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc29uZ3Mgc3RhdGVcbiAgICAvLyBVcGRhdGUgc29uZ3Mgc3RhdGVcbnNldFNvbmdzKHByZXZTb25ncyA9PlxuICBwcmV2U29uZ3MubWFwKHNvbmcgPT5cbiAgICBzb25nLmlkID09PSBzb25nSWRcbiAgICAgID8ge1xuICAgICAgICAgIC4uLnNvbmcsXG4gICAgICAgICAgaXNMaWtlZDogIWlzQ3VycmVudGx5TGlrZWQsXG4gICAgICAgICAgbGlrZXM6IHNvbmcubGlrZXMgKyAoaXNDdXJyZW50bHlMaWtlZCA/IC0xIDogMSksXG4gICAgICAgIH1cbiAgICAgIDogc29uZ1xuICApXG4pO1xuXG5cbiAgICAvLyBVcGRhdGUgcGxheWxpc3RzIHN0YXRlXG4gICAgc2V0UGxheWxpc3RzKHByZXZQbGF5bGlzdHMgPT5cbiAgICAgIHByZXZQbGF5bGlzdHMubWFwKHBsYXlsaXN0ID0+ICh7XG4gICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICBzb25nczogcGxheWxpc3Quc29uZ3MubWFwKHNvbmcgPT5cbiAgICAgICAgICBzb25nLmlkID09PSBzb25nSWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIC4uLnNvbmcsXG4gICAgICAgICAgICAgICAgaXNMaWtlZDogIWlzQ3VycmVudGx5TGlrZWQsXG4gICAgICAgICAgICAgICAgbGlrZXM6IHNvbmcubGlrZXMgKyAoaXNDdXJyZW50bHlMaWtlZCA/IC0xIDogMSksXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogc29uZ1xuICAgICAgICApLFxuICAgICAgfSkpXG4gICAgKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB0b2dnbGluZyBsaWtlOicsIGVycm9yKTtcbiAgfVxufTtcblxuXG4gIC8vIENyZWF0ZSBwbGF5bGlzdFxuICBjb25zdCBjcmVhdGVQbGF5bGlzdCA9IGFzeW5jIChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB1c2VyX2lkOiB1c2VyLmlkLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIGNvbnN0IG5ld1BsYXlsaXN0OiBQbGF5bGlzdCA9IHtcbiAgICAgICAgaWQ6IGRhdGEuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICBzb25nQ291bnQ6IDAsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTc2MzA3NS9wZXhlbHMtcGhvdG8tMTc2MzA3NS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDAnLFxuICAgICAgICBzb25nczogW11cbiAgICAgIH1cblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gWy4uLnByZXYsIG5ld1BsYXlsaXN0XSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIHBsYXlsaXN0XG4gIGNvbnN0IGRlbGV0ZVBsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ2lkJywgcGFyc2VJbnQocGxheWxpc3RJZCkpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gcHJldi5maWx0ZXIocGxheWxpc3QgPT4gcGxheWxpc3QuaWQgIT09IHBsYXlsaXN0SWQpKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBSZW5hbWUgcGxheWxpc3RcbiAgY29uc3QgcmVuYW1lUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAudXBkYXRlKHsgbmFtZTogbmV3TmFtZSB9KVxuICAgICAgICAuZXEoJ2lkJywgcGFyc2VJbnQocGxheWxpc3RJZCkpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKHBsYXlsaXN0ID0+IFxuICAgICAgICAgIHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkIFxuICAgICAgICAgICAgPyB7IC4uLnBsYXlsaXN0LCBuYW1lOiBuZXdOYW1lIH1cbiAgICAgICAgICAgIDogcGxheWxpc3RcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5hbWluZyBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgc29uZyB0byBwbGF5bGlzdFxuICBjb25zdCBhZGRTb25nVG9QbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcsIHNvbmc6IFNvbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdF9zb25ncycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHBsYXlsaXN0X2lkOiBwYXJzZUludChwbGF5bGlzdElkKSxcbiAgICAgICAgICBzb25nX2lkOiBzb25nLmZpbGVfaWRcbiAgICAgICAgfSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAocGxheWxpc3QgPT4ge1xuICAgICAgICAgIGlmIChwbGF5bGlzdC5pZCA9PT0gcGxheWxpc3RJZCkge1xuICAgICAgICAgICAgY29uc3Qgc29uZ0V4aXN0cyA9IHBsYXlsaXN0LnNvbmdzLnNvbWUocyA9PiBzLmlkID09PSBzb25nLmlkKVxuICAgICAgICAgICAgaWYgKCFzb25nRXhpc3RzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTb25ncyA9IFsuLi5wbGF5bGlzdC5zb25ncywgc29uZ11cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5wbGF5bGlzdCxcbiAgICAgICAgICAgICAgICBzb25nczogdXBkYXRlZFNvbmdzLFxuICAgICAgICAgICAgICAgIHNvbmdDb3VudDogdXBkYXRlZFNvbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbWFnZTogdXBkYXRlZFNvbmdzWzBdPy5pbWFnZSB8fCBwbGF5bGlzdC5pbWFnZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwbGF5bGlzdFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgc29uZyB0byBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgc29uZyBmcm9tIHBsYXlsaXN0XG4gIGNvbnN0IHJlbW92ZVNvbmdGcm9tUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nLCBzb25nSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0X3NvbmdzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgncGxheWxpc3RfaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCdzb25nX2lkJywgcGFyc2VJbnQoc29uZ0lkKSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAocGxheWxpc3QgPT4ge1xuICAgICAgICAgIGlmIChwbGF5bGlzdC5pZCA9PT0gcGxheWxpc3RJZCkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNvbmdzID0gcGxheWxpc3Quc29uZ3MuZmlsdGVyKHNvbmcgPT4gc29uZy5pZCAhPT0gc29uZ0lkKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ucGxheWxpc3QsXG4gICAgICAgICAgICAgIHNvbmdzOiB1cGRhdGVkU29uZ3MsXG4gICAgICAgICAgICAgIHNvbmdDb3VudDogdXBkYXRlZFNvbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgaW1hZ2U6IHVwZGF0ZWRTb25nc1swXT8uaW1hZ2UgfHwgJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGxheWxpc3RcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3Zpbmcgc29uZyBmcm9tIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBsYXN0IHNvbmcgaW4gdXNlciBwcm9maWxlXG4gIGNvbnN0IHVwZGF0ZUxhc3RTb25nID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAudXBkYXRlKHsgbGFzdF9zb25nX2ZpbGVfaWQ6IHBhcnNlSW50KHNvbmdJZCkgfSlcbiAgICAgICAgLmVxKCdpZCcsIHVzZXIuaWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgbGFzdCBzb25nOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlY29yZCBsaXN0ZW5pbmcgaGlzdG9yeSB3aXRoIHByb3BlciB0aW1lIHRyYWNraW5nXG4gIGNvbnN0IHJlY29yZExpc3RlbmluZ0hpc3RvcnkgPSBhc3luYyAoc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHByZXZpb3VzIHNvbmcgcGxheWluZywgcmVjb3JkIGl0cyBsaXN0ZW5pbmcgdGltZVxuICAgICAgaWYgKGN1cnJlbnRTb25nUmVmLmN1cnJlbnQgJiYgY3VycmVudFNvbmdTdGFydFRpbWUpIHtcbiAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBtaW51dGVzTGlzdGVuZWQgPSAoZW5kVGltZS5nZXRUaW1lKCkgLSBjdXJyZW50U29uZ1N0YXJ0VGltZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCk7XG5cbiAgICBpZiAobWludXRlc0xpc3RlbmVkID4gMC4xKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtaW51dGVzID0gTWF0aC5yb3VuZChtaW51dGVzTGlzdGVuZWQgKiAxMDApIC8gMTAwO1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoJ3Vwc2VydF9oaXN0b3J5X21pbnV0ZXMnLCB7XG4gICAgICAgICAgdXNlcl91dWlkOiB1c2VyLmlkLFxuICAgICAgICAgIHNvbmdfZmlsZV9pZDogcGFyc2VJbnQoY3VycmVudFNvbmdSZWYuY3VycmVudCksXG4gICAgICAgICAgbWludXRlczogbWludXRlcyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlY29yZGluZyBzb25nIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgSGlzdG9yeSB1cGRhdGVkOiArJHttaW51dGVzfSBtaW5zIGZvciBzb25nICR7Y3VycmVudFNvbmdSZWYuY3VycmVudH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVjb3JkaW5nIHByZXZpb3VzIHNvbmcgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAgIC8vIFNldCBuZXcgc29uZyBhcyBjdXJyZW50XG4gICAgY3VycmVudFNvbmdSZWYuY3VycmVudCA9IHNvbmdJZFxuICAgIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lKG5ldyBEYXRlKCkpXG4gICAgXG4gICAgLy8gVXBkYXRlIGxhc3Qgc29uZyBpbiB1c2VyIHByb2ZpbGVcbiAgICBhd2FpdCB1cGRhdGVMYXN0U29uZyhzb25nSWQpXG50cnkge1xuICBhd2FpdCBzdXBhYmFzZS5ycGMoJ2luY3JlbWVudF9zb25nX3ZpZXdzJywgeyBzb25nX2ZpbGVfaWQ6IHBhcnNlSW50KHNvbmdJZCkgfSk7XG59IGNhdGNoIChlcnJvcikge1xuICBjb25zb2xlLmVycm9yKCdFcnJvciBpbmNyZW1lbnRpbmcgc29uZyB2aWV3czonLCBlcnJvcik7XG59XG5cbiAgfVxuXG4gIC8vIFN0b3AgY3VycmVudCBzb25nIHRyYWNraW5nICh3aGVuIHBsYXllciBpcyBjbG9zZWQpXG4gIGNvbnN0IHN0b3BDdXJyZW50U29uZ1RyYWNraW5nID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChjdXJyZW50U29uZ1JlZi5jdXJyZW50ICYmIGN1cnJlbnRTb25nU3RhcnRUaW1lICYmIHVzZXIpIHtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpXG4gICAgICBjb25zdCBtaW51dGVzTGlzdGVuZWQgPSAoZW5kVGltZS5nZXRUaW1lKCkgLSBjdXJyZW50U29uZ1N0YXJ0VGltZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MClcbiAgICAgIFxuICAgICAgaWYgKG1pbnV0ZXNMaXN0ZW5lZCA+IDAuMSkge1xuICB0cnkge1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLnJvdW5kKG1pbnV0ZXNMaXN0ZW5lZCAqIDEwMCkgLyAxMDA7XG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCd1cHNlcnRfaGlzdG9yeV9taW51dGVzJywge1xuICAgICAgdXNlcl91dWlkOiB1c2VyLmlkLFxuICAgICAgc29uZ19maWxlX2lkOiBwYXJzZUludChjdXJyZW50U29uZ1JlZi5jdXJyZW50KSxcbiAgICAgIG1pbnV0ZXM6IG1pbnV0ZXMsXG4gICAgfSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZWNvcmRpbmcgc29uZyBoaXN0b3J5IG9uIHN0b3A6JywgZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+bkSBIaXN0b3J5IHVwZGF0ZWQgb24gc3RvcDogKyR7bWludXRlc30gbWlucyBmb3Igc29uZyAke2N1cnJlbnRTb25nUmVmLmN1cnJlbnR9YCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlY29yZGluZyBmaW5hbCBzb25nIGhpc3Rvcnk6JywgZXJyb3IpO1xuICB9XG59XG5cbiAgICB9XG5cbiAgICBjdXJyZW50U29uZ1JlZi5jdXJyZW50ID0gbnVsbFxuICAgIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lKG51bGwpXG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgIC8vIFJlc2V0IGRhdGEgd2hlbiB1c2VyIGxvZ3Mgb3V0XG4gICAgICAgIHNldFNvbmdzKFtdKVxuICAgICAgICBzZXRQbGF5bGlzdHMoW10pXG4gICAgICAgIHNldExpa2VkU29uZ3MobmV3IFNldCgpKVxuICAgICAgICBzZXRMYXN0UGxheWVkU29uZyhudWxsKVxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbZmV0Y2hTb25ncygpLCBmZXRjaFBsYXlsaXN0cygpXSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgZGF0YTonLCBlcnJvcilcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9hZERhdGEoKVxuICB9LCBbdXNlcl0pXG5cbiAgcmV0dXJuIHtcbiAgICBzb25ncyxcbiAgICBwbGF5bGlzdHMsXG4gICAgbGlrZWRTb25nczogc29uZ3MuZmlsdGVyKHNvbmcgPT4gc29uZy5pc0xpa2VkKSxcbiAgICBsYXN0UGxheWVkU29uZyxcbiAgICBsb2FkaW5nLFxuICAgIHRvZ2dsZUxpa2UsXG4gICAgY3JlYXRlUGxheWxpc3QsXG4gICAgZGVsZXRlUGxheWxpc3QsXG4gICAgcmVuYW1lUGxheWxpc3QsXG4gICAgYWRkU29uZ1RvUGxheWxpc3QsXG4gICAgcmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCxcbiAgICByZWNvcmRMaXN0ZW5pbmdIaXN0b3J5LFxuICAgIHN0b3BDdXJyZW50U29uZ1RyYWNraW5nLFxuICAgIHJlZnJlc2hEYXRhOiAoKSA9PiB7XG4gICAgICBmZXRjaFNvbmdzKClcbiAgICAgIGZldGNoUGxheWxpc3RzKClcbiAgICB9LFxuICAgIGdldFBlcnNvbmFsaXplZFNvbmdzXG4gIH1cbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJzdXBhYmFzZSIsInVzZVN1cGFiYXNlRGF0YSIsInVzZXIiLCJzb25ncyIsInNldFNvbmdzIiwicGxheWxpc3RzIiwic2V0UGxheWxpc3RzIiwibGlrZWRTb25ncyIsInNldExpa2VkU29uZ3MiLCJTZXQiLCJsYXN0UGxheWVkU29uZyIsInNldExhc3RQbGF5ZWRTb25nIiwibG9hZGluZyIsInNldExvYWRpbmciLCJjdXJyZW50U29uZ1N0YXJ0VGltZSIsInNldEN1cnJlbnRTb25nU3RhcnRUaW1lIiwiY3VycmVudFNvbmdSZWYiLCJjb252ZXJ0RGF0YWJhc2VTb25nIiwiZGJTb25nIiwiaXNMaWtlZCIsImZpbGVfaWQiLCJpbWdfaWQiLCJuYW1lIiwiYXJ0aXN0IiwibGFuZ3VhZ2UiLCJ0YWdzIiwidmlld3MiLCJsaWtlcyIsImlkIiwidG9TdHJpbmciLCJpbWFnZSIsImZldGNoU29uZ3MiLCJkYXRhIiwic29uZ3NEYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJ1c2VyTGlrZWRTb25ncyIsImxpa2VkRGF0YSIsImVxIiwibWFwIiwiaXRlbSIsInNvbmdfaWQiLCJjb252ZXJ0ZWRTb25ncyIsInNvbmciLCJoYXMiLCJzb3J0ZWRTb25ncyIsInNvcnQiLCJhIiwiYiIsImFTY29yZSIsImJTY29yZSIsInVzZXJEYXRhIiwic2luZ2xlIiwibGFzdF9zb25nX2ZpbGVfaWQiLCJsYXN0U29uZyIsImZpbmQiLCJjb25zb2xlIiwiZ2V0UGVyc29uYWxpemVkU29uZ3MiLCJ1c2VySWQiLCJjdXJyZW50U29uZyIsImxpc3RlbmVkU29uZ3MiLCJoaXN0b3J5IiwiaGlzdG9yeU1hcCIsIk1hcCIsImgiLCJtaW51dGVzX2xpc3RlbmVkIiwicmVjb21tZW5kYXRpb25zIiwiZmlsdGVyIiwibG9nIiwic2NvcmUiLCJtYXRjaGluZ1RhZ3MiLCJ0YWciLCJpbmNsdWRlcyIsImxlbmd0aCIsImxpc3RlbmVkTWludXRlcyIsImdldCIsIk1hdGgiLCJyYW5kb20iLCJ0b3A1Iiwic2xpY2UiLCJlbnRyeSIsInMiLCJzaXplIiwiZmV0Y2hQbGF5bGlzdHMiLCJwbGF5bGlzdHNEYXRhIiwiY29udmVydGVkUGxheWxpc3RzIiwicGxheWxpc3QiLCJwbGF5bGlzdFNvbmdzIiwicGxheWxpc3Rfc29uZ3MiLCJwcyIsInNvbmdDb3VudCIsInRvZ2dsZUxpa2UiLCJzb25nSWQiLCJzb25nRmlsZUlkIiwicGFyc2VJbnQiLCJpc0N1cnJlbnRseUxpa2VkIiwiZGVsZXRlIiwicnBjIiwic29uZ19maWxlX2lkIiwicHJldiIsIm5ld1NldCIsImluc2VydCIsInVzZXJfaWQiLCJhZGQiLCJwcmV2U29uZ3MiLCJwcmV2UGxheWxpc3RzIiwiY3JlYXRlUGxheWxpc3QiLCJuZXdQbGF5bGlzdCIsImRlbGV0ZVBsYXlsaXN0IiwicGxheWxpc3RJZCIsInJlbmFtZVBsYXlsaXN0IiwibmV3TmFtZSIsInVwZGF0ZSIsImFkZFNvbmdUb1BsYXlsaXN0IiwicGxheWxpc3RfaWQiLCJzb25nRXhpc3RzIiwic29tZSIsInVwZGF0ZWRTb25ncyIsInJlbW92ZVNvbmdGcm9tUGxheWxpc3QiLCJ1cGRhdGVMYXN0U29uZyIsInJlY29yZExpc3RlbmluZ0hpc3RvcnkiLCJjdXJyZW50IiwiZW5kVGltZSIsIkRhdGUiLCJtaW51dGVzTGlzdGVuZWQiLCJnZXRUaW1lIiwibWludXRlcyIsInJvdW5kIiwidXNlcl91dWlkIiwic3RvcEN1cnJlbnRTb25nVHJhY2tpbmciLCJsb2FkRGF0YSIsIlByb21pc2UiLCJhbGwiLCJyZWZyZXNoRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSupabaseData.ts\n"));

/***/ })

});